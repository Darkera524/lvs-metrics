// Code generated by protoc-gen-go.
// source: pb/config/config.proto
// DO NOT EDIT!

/*
Package config is a generated protocol buffer package.

It is generated from these files:
	pb/config/config.proto

It has these top-level messages:
	Host
	Backend
	Vlan
	Healthcheck
	VserverEntry
	AccessGrant
	Vserver
	MisconfiguredVserver
	Attribute
	Metadata
	Cluster
*/
package config

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type Protocol int32

const (
	Protocol_TCP Protocol = 1
	Protocol_UDP Protocol = 2
)

var Protocol_name = map[int32]string{
	1: "TCP",
	2: "UDP",
}
var Protocol_value = map[string]int32{
	"TCP": 1,
	"UDP": 2,
}

func (x Protocol) Enum() *Protocol {
	p := new(Protocol)
	*p = x
	return p
}
func (x Protocol) String() string {
	return proto.EnumName(Protocol_name, int32(x))
}
func (x *Protocol) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Protocol_value, data, "Protocol")
	if err != nil {
		return err
	}
	*x = Protocol(value)
	return nil
}
func (Protocol) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Servicedb statuses
type Host_Status int32

const (
	Host_PRODUCTION Host_Status = 1
	Host_TESTING    Host_Status = 2
	Host_BUILDING   Host_Status = 3
	Host_STANDBY    Host_Status = 4
	Host_FAILURE    Host_Status = 5
	Host_DISABLED   Host_Status = 6
	Host_PROPOSED   Host_Status = 7
)

var Host_Status_name = map[int32]string{
	1: "PRODUCTION",
	2: "TESTING",
	3: "BUILDING",
	4: "STANDBY",
	5: "FAILURE",
	6: "DISABLED",
	7: "PROPOSED",
}
var Host_Status_value = map[string]int32{
	"PRODUCTION": 1,
	"TESTING":    2,
	"BUILDING":   3,
	"STANDBY":    4,
	"FAILURE":    5,
	"DISABLED":   6,
	"PROPOSED":   7,
}

func (x Host_Status) Enum() *Host_Status {
	p := new(Host_Status)
	*p = x
	return p
}
func (x Host_Status) String() string {
	return proto.EnumName(Host_Status_name, int32(x))
}
func (x *Host_Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Host_Status_value, data, "Host_Status")
	if err != nil {
		return err
	}
	*x = Host_Status(value)
	return nil
}
func (Host_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type Healthcheck_Type int32

const (
	Healthcheck_ICMP_PING Healthcheck_Type = 1
	Healthcheck_UDP       Healthcheck_Type = 2
	Healthcheck_TCP       Healthcheck_Type = 3
	Healthcheck_HTTP      Healthcheck_Type = 4
	Healthcheck_HTTPS     Healthcheck_Type = 5
	Healthcheck_DNS       Healthcheck_Type = 6
	Healthcheck_TCP_TLS   Healthcheck_Type = 7
	Healthcheck_RADIUS    Healthcheck_Type = 8
)

var Healthcheck_Type_name = map[int32]string{
	1: "ICMP_PING",
	2: "UDP",
	3: "TCP",
	4: "HTTP",
	5: "HTTPS",
	6: "DNS",
	7: "TCP_TLS",
	8: "RADIUS",
}
var Healthcheck_Type_value = map[string]int32{
	"ICMP_PING": 1,
	"UDP":       2,
	"TCP":       3,
	"HTTP":      4,
	"HTTPS":     5,
	"DNS":       6,
	"TCP_TLS":   7,
	"RADIUS":    8,
}

func (x Healthcheck_Type) Enum() *Healthcheck_Type {
	p := new(Healthcheck_Type)
	*p = x
	return p
}
func (x Healthcheck_Type) String() string {
	return proto.EnumName(Healthcheck_Type_name, int32(x))
}
func (x *Healthcheck_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Healthcheck_Type_value, data, "Healthcheck_Type")
	if err != nil {
		return err
	}
	*x = Healthcheck_Type(value)
	return nil
}
func (Healthcheck_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

type Healthcheck_Mode int32

const (
	Healthcheck_PLAIN Healthcheck_Mode = 1
	Healthcheck_DSR   Healthcheck_Mode = 2
)

var Healthcheck_Mode_name = map[int32]string{
	1: "PLAIN",
	2: "DSR",
}
var Healthcheck_Mode_value = map[string]int32{
	"PLAIN": 1,
	"DSR":   2,
}

func (x Healthcheck_Mode) Enum() *Healthcheck_Mode {
	p := new(Healthcheck_Mode)
	*p = x
	return p
}
func (x Healthcheck_Mode) String() string {
	return proto.EnumName(Healthcheck_Mode_name, int32(x))
}
func (x *Healthcheck_Mode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Healthcheck_Mode_value, data, "Healthcheck_Mode")
	if err != nil {
		return err
	}
	*x = Healthcheck_Mode(value)
	return nil
}
func (Healthcheck_Mode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 1} }

// See --scheduler in man ipvsadm(8)
type VserverEntry_Scheduler int32

const (
	VserverEntry_RR  VserverEntry_Scheduler = 1
	VserverEntry_WRR VserverEntry_Scheduler = 2
	VserverEntry_LC  VserverEntry_Scheduler = 3
	VserverEntry_WLC VserverEntry_Scheduler = 4
	VserverEntry_SH  VserverEntry_Scheduler = 5
)

var VserverEntry_Scheduler_name = map[int32]string{
	1: "RR",
	2: "WRR",
	3: "LC",
	4: "WLC",
	5: "SH",
}
var VserverEntry_Scheduler_value = map[string]int32{
	"RR":  1,
	"WRR": 2,
	"LC":  3,
	"WLC": 4,
	"SH":  5,
}

func (x VserverEntry_Scheduler) Enum() *VserverEntry_Scheduler {
	p := new(VserverEntry_Scheduler)
	*p = x
	return p
}
func (x VserverEntry_Scheduler) String() string {
	return proto.EnumName(VserverEntry_Scheduler_name, int32(x))
}
func (x *VserverEntry_Scheduler) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VserverEntry_Scheduler_value, data, "VserverEntry_Scheduler")
	if err != nil {
		return err
	}
	*x = VserverEntry_Scheduler(value)
	return nil
}
func (VserverEntry_Scheduler) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type VserverEntry_Mode int32

const (
	// See --gatewaying in man ipvsadm(8)
	VserverEntry_DSR VserverEntry_Mode = 1
	// See --masquerding in man ipvsadm(8)
	VserverEntry_NAT VserverEntry_Mode = 2
)

var VserverEntry_Mode_name = map[int32]string{
	1: "DSR",
	2: "NAT",
}
var VserverEntry_Mode_value = map[string]int32{
	"DSR": 1,
	"NAT": 2,
}

func (x VserverEntry_Mode) Enum() *VserverEntry_Mode {
	p := new(VserverEntry_Mode)
	*p = x
	return p
}
func (x VserverEntry_Mode) String() string {
	return proto.EnumName(VserverEntry_Mode_name, int32(x))
}
func (x *VserverEntry_Mode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VserverEntry_Mode_value, data, "VserverEntry_Mode")
	if err != nil {
		return err
	}
	*x = VserverEntry_Mode(value)
	return nil
}
func (VserverEntry_Mode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 1} }

type AccessGrant_Role int32

const (
	AccessGrant_ADMIN AccessGrant_Role = 1
	AccessGrant_OPS   AccessGrant_Role = 2
)

var AccessGrant_Role_name = map[int32]string{
	1: "ADMIN",
	2: "OPS",
}
var AccessGrant_Role_value = map[string]int32{
	"ADMIN": 1,
	"OPS":   2,
}

func (x AccessGrant_Role) Enum() *AccessGrant_Role {
	p := new(AccessGrant_Role)
	*p = x
	return p
}
func (x AccessGrant_Role) String() string {
	return proto.EnumName(AccessGrant_Role_name, int32(x))
}
func (x *AccessGrant_Role) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AccessGrant_Role_value, data, "AccessGrant_Role")
	if err != nil {
		return err
	}
	*x = AccessGrant_Role(value)
	return nil
}
func (AccessGrant_Role) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

type AccessGrant_Type int32

const (
	AccessGrant_USER  AccessGrant_Type = 1
	AccessGrant_GROUP AccessGrant_Type = 2
)

var AccessGrant_Type_name = map[int32]string{
	1: "USER",
	2: "GROUP",
}
var AccessGrant_Type_value = map[string]int32{
	"USER":  1,
	"GROUP": 2,
}

func (x AccessGrant_Type) Enum() *AccessGrant_Type {
	p := new(AccessGrant_Type)
	*p = x
	return p
}
func (x AccessGrant_Type) String() string {
	return proto.EnumName(AccessGrant_Type_name, int32(x))
}
func (x *AccessGrant_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AccessGrant_Type_value, data, "AccessGrant_Type")
	if err != nil {
		return err
	}
	*x = AccessGrant_Type(value)
	return nil
}
func (AccessGrant_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 1} }

type Host struct {
	// Fully qualified hostname
	Fqdn *string `protobuf:"bytes,1,req,name=fqdn" json:"fqdn,omitempty"`
	// An IPv4 address and prefix length in CIDR format
	Ipv4 *string `protobuf:"bytes,2,opt,name=ipv4" json:"ipv4,omitempty"`
	// An IPv6 address and prefix length in CIDR format
	Ipv6 *string `protobuf:"bytes,3,opt,name=ipv6" json:"ipv6,omitempty"`
	// Host status
	Status           *Host_Status `protobuf:"varint,4,opt,name=status,enum=Host_Status" json:"status,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *Host) Reset()                    { *m = Host{} }
func (m *Host) String() string            { return proto.CompactTextString(m) }
func (*Host) ProtoMessage()               {}
func (*Host) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Host) GetFqdn() string {
	if m != nil && m.Fqdn != nil {
		return *m.Fqdn
	}
	return ""
}

func (m *Host) GetIpv4() string {
	if m != nil && m.Ipv4 != nil {
		return *m.Ipv4
	}
	return ""
}

func (m *Host) GetIpv6() string {
	if m != nil && m.Ipv6 != nil {
		return *m.Ipv6
	}
	return ""
}

func (m *Host) GetStatus() Host_Status {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Host_PRODUCTION
}

type Backend struct {
	Host             *Host  `protobuf:"bytes,1,req,name=host" json:"host,omitempty"`
	Weight           *int32 `protobuf:"varint,2,opt,name=weight,def=1" json:"weight,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Backend) Reset()                    { *m = Backend{} }
func (m *Backend) String() string            { return proto.CompactTextString(m) }
func (*Backend) ProtoMessage()               {}
func (*Backend) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

const Default_Backend_Weight int32 = 1

func (m *Backend) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *Backend) GetWeight() int32 {
	if m != nil && m.Weight != nil {
		return *m.Weight
	}
	return Default_Backend_Weight
}

type Vlan struct {
	VlanId           *int32 `protobuf:"varint,1,req,name=vlan_id" json:"vlan_id,omitempty"`
	Host             *Host  `protobuf:"bytes,2,req,name=host" json:"host,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Vlan) Reset()                    { *m = Vlan{} }
func (m *Vlan) String() string            { return proto.CompactTextString(m) }
func (*Vlan) ProtoMessage()               {}
func (*Vlan) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Vlan) GetVlanId() int32 {
	if m != nil && m.VlanId != nil {
		return *m.VlanId
	}
	return 0
}

func (m *Vlan) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

// TODO(angusc): Use different message types for the different healthcheck
// types.
type Healthcheck struct {
	Type *Healthcheck_Type `protobuf:"varint,1,req,name=type,enum=Healthcheck_Type" json:"type,omitempty"`
	// Healthcheck interval in seconds
	Interval *int32 `protobuf:"varint,2,opt,name=interval,def=10" json:"interval,omitempty"`
	// Healthcheck timeout in seconds
	Timeout *int32 `protobuf:"varint,3,opt,name=timeout,def=5" json:"timeout,omitempty"`
	// Healthcheck port.  For Vserver healthchecks, this field is required.
	// For VserverEntry healthchecks, it is optional and uses the VserverEntry
	// port by default.
	Port *int32 `protobuf:"varint,4,opt,name=port" json:"port,omitempty"`
	// String to send for UDP/TCP/HTTP(S) healthcheck.
	Send *string `protobuf:"bytes,5,opt,name=send" json:"send,omitempty"`
	// Expected response for UDP/TCP/HTTP(S) healthcheck.
	Receive *string `protobuf:"bytes,6,opt,name=receive" json:"receive,omitempty"`
	// Expected response code for healthcheck.
	Code *int32 `protobuf:"varint,7,opt,name=code" json:"code,omitempty"`
	// The Mode of this healthcheck.
	Mode *Healthcheck_Mode `protobuf:"varint,8,opt,name=mode,enum=Healthcheck_Mode,def=1" json:"mode,omitempty"`
	// The HTTP request method to use for an HTTP(S) healthcheck.
	Method *string `protobuf:"bytes,9,opt,name=method" json:"method,omitempty"`
	// Perform a healthcheck against an HTTP proxy.
	Proxy *bool `protobuf:"varint,10,opt,name=proxy" json:"proxy,omitempty"`
	// Do TLS verification.
	TlsVerify *bool `protobuf:"varint,11,opt,name=tls_verify,def=1" json:"tls_verify,omitempty"`
	// Number of retries before a healthcheck is considered to have failed.
	Retries          *int32 `protobuf:"varint,12,opt,name=retries" json:"retries,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Healthcheck) Reset()                    { *m = Healthcheck{} }
func (m *Healthcheck) String() string            { return proto.CompactTextString(m) }
func (*Healthcheck) ProtoMessage()               {}
func (*Healthcheck) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

const Default_Healthcheck_Interval int32 = 10
const Default_Healthcheck_Timeout int32 = 5
const Default_Healthcheck_Mode Healthcheck_Mode = Healthcheck_PLAIN
const Default_Healthcheck_TlsVerify bool = true

func (m *Healthcheck) GetType() Healthcheck_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Healthcheck_ICMP_PING
}

func (m *Healthcheck) GetInterval() int32 {
	if m != nil && m.Interval != nil {
		return *m.Interval
	}
	return Default_Healthcheck_Interval
}

func (m *Healthcheck) GetTimeout() int32 {
	if m != nil && m.Timeout != nil {
		return *m.Timeout
	}
	return Default_Healthcheck_Timeout
}

func (m *Healthcheck) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *Healthcheck) GetSend() string {
	if m != nil && m.Send != nil {
		return *m.Send
	}
	return ""
}

func (m *Healthcheck) GetReceive() string {
	if m != nil && m.Receive != nil {
		return *m.Receive
	}
	return ""
}

func (m *Healthcheck) GetCode() int32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *Healthcheck) GetMode() Healthcheck_Mode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return Default_Healthcheck_Mode
}

func (m *Healthcheck) GetMethod() string {
	if m != nil && m.Method != nil {
		return *m.Method
	}
	return ""
}

func (m *Healthcheck) GetProxy() bool {
	if m != nil && m.Proxy != nil {
		return *m.Proxy
	}
	return false
}

func (m *Healthcheck) GetTlsVerify() bool {
	if m != nil && m.TlsVerify != nil {
		return *m.TlsVerify
	}
	return Default_Healthcheck_TlsVerify
}

func (m *Healthcheck) GetRetries() int32 {
	if m != nil && m.Retries != nil {
		return *m.Retries
	}
	return 0
}

type VserverEntry struct {
	Protocol  *Protocol               `protobuf:"varint,1,req,name=protocol,enum=Protocol" json:"protocol,omitempty"`
	Port      *int32                  `protobuf:"varint,2,req,name=port" json:"port,omitempty"`
	Scheduler *VserverEntry_Scheduler `protobuf:"varint,5,opt,name=scheduler,enum=VserverEntry_Scheduler,def=4" json:"scheduler,omitempty"`
	Mode      *VserverEntry_Mode      `protobuf:"varint,6,opt,name=mode,enum=VserverEntry_Mode,def=1" json:"mode,omitempty"`
	// See --persisent in man ipvsadm(8)
	Persistence *int32 `protobuf:"varint,7,opt,name=persistence" json:"persistence,omitempty"`
	// Continue sending packets for existing connections to the same backend,
	// even when that backend is failing healthchecks.
	Quiescent *bool `protobuf:"varint,8,opt,name=quiescent" json:"quiescent,omitempty"`
	// The minimum fraction of backends that must be healthy for the vserver to be
	// active. If the number of backends falls below this watermark, the vserver
	// is considered unhealthy. Valid values are 0.0 to 1.0. If unset, the value
	// of server_high_watermark is used.
	ServerLowWatermark *float32 `protobuf:"fixed32,9,opt,name=server_low_watermark" json:"server_low_watermark,omitempty"`
	// The minimum fraction of backends that must be healthy for vserver to become
	// active. Default is 0.0 .
	ServerHighWatermark *float32 `protobuf:"fixed32,10,opt,name=server_high_watermark" json:"server_high_watermark,omitempty"`
	// --l-threshold per man ipvsadm(8)
	Lthreshold *int32 `protobuf:"varint,11,opt,name=lthreshold" json:"lthreshold,omitempty"`
	// --u-threshold per man ipvsadm(8)
	Uthreshold *int32 `protobuf:"varint,12,opt,name=uthreshold" json:"uthreshold,omitempty"`
	// The healthchecks to perform on the backends
	Healthcheck []*Healthcheck `protobuf:"bytes,13,rep,name=healthcheck" json:"healthcheck,omitempty"`
	// Use "one packet" load balancing
	OnePacket        *bool  `protobuf:"varint,14,opt,name=one_packet" json:"one_packet,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *VserverEntry) Reset()                    { *m = VserverEntry{} }
func (m *VserverEntry) String() string            { return proto.CompactTextString(m) }
func (*VserverEntry) ProtoMessage()               {}
func (*VserverEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

const Default_VserverEntry_Scheduler VserverEntry_Scheduler = VserverEntry_WLC
const Default_VserverEntry_Mode VserverEntry_Mode = VserverEntry_DSR

func (m *VserverEntry) GetProtocol() Protocol {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return Protocol_TCP
}

func (m *VserverEntry) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *VserverEntry) GetScheduler() VserverEntry_Scheduler {
	if m != nil && m.Scheduler != nil {
		return *m.Scheduler
	}
	return Default_VserverEntry_Scheduler
}

func (m *VserverEntry) GetMode() VserverEntry_Mode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return Default_VserverEntry_Mode
}

func (m *VserverEntry) GetPersistence() int32 {
	if m != nil && m.Persistence != nil {
		return *m.Persistence
	}
	return 0
}

func (m *VserverEntry) GetQuiescent() bool {
	if m != nil && m.Quiescent != nil {
		return *m.Quiescent
	}
	return false
}

func (m *VserverEntry) GetServerLowWatermark() float32 {
	if m != nil && m.ServerLowWatermark != nil {
		return *m.ServerLowWatermark
	}
	return 0
}

func (m *VserverEntry) GetServerHighWatermark() float32 {
	if m != nil && m.ServerHighWatermark != nil {
		return *m.ServerHighWatermark
	}
	return 0
}

func (m *VserverEntry) GetLthreshold() int32 {
	if m != nil && m.Lthreshold != nil {
		return *m.Lthreshold
	}
	return 0
}

func (m *VserverEntry) GetUthreshold() int32 {
	if m != nil && m.Uthreshold != nil {
		return *m.Uthreshold
	}
	return 0
}

func (m *VserverEntry) GetHealthcheck() []*Healthcheck {
	if m != nil {
		return m.Healthcheck
	}
	return nil
}

func (m *VserverEntry) GetOnePacket() bool {
	if m != nil && m.OnePacket != nil {
		return *m.OnePacket
	}
	return false
}

type AccessGrant struct {
	// The user or group
	Grantee *string `protobuf:"bytes,1,req,name=grantee" json:"grantee,omitempty"`
	// The Role granted to the grantee
	Role *AccessGrant_Role `protobuf:"varint,2,req,name=role,enum=AccessGrant_Role" json:"role,omitempty"`
	// The Type of AccessGrant
	Type             *AccessGrant_Type `protobuf:"varint,3,req,name=type,enum=AccessGrant_Type" json:"type,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *AccessGrant) Reset()                    { *m = AccessGrant{} }
func (m *AccessGrant) String() string            { return proto.CompactTextString(m) }
func (*AccessGrant) ProtoMessage()               {}
func (*AccessGrant) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *AccessGrant) GetGrantee() string {
	if m != nil && m.Grantee != nil {
		return *m.Grantee
	}
	return ""
}

func (m *AccessGrant) GetRole() AccessGrant_Role {
	if m != nil && m.Role != nil {
		return *m.Role
	}
	return AccessGrant_ADMIN
}

func (m *AccessGrant) GetType() AccessGrant_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return AccessGrant_USER
}

type Vserver struct {
	// The name of this vserver.
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// VIP hostname and IP(s).
	EntryAddress *Host `protobuf:"bytes,2,req,name=entry_address" json:"entry_address,omitempty"`
	// Contact info for Responsible Party
	Rp *string `protobuf:"bytes,3,req,name=rp" json:"rp,omitempty"`
	// Use firewall mark instead of individual service configurations.
	UseFwm       *bool           `protobuf:"varint,4,opt,name=use_fwm" json:"use_fwm,omitempty"`
	VserverEntry []*VserverEntry `protobuf:"bytes,5,rep,name=vserver_entry" json:"vserver_entry,omitempty"`
	// The list of backends for this vserver.
	// TODO(mibus): Kill legacy_backend, and move "backend" down the list.
	LegacyBackend []*Host    `protobuf:"bytes,6,rep,name=legacy_backend" json:"legacy_backend,omitempty"`
	Backend       []*Backend `protobuf:"bytes,10,rep,name=backend" json:"backend,omitempty"`
	// The healthchecks to perform on the backends, in addition to those that are
	// VserverEntry specific.
	Healthcheck []*Healthcheck `protobuf:"bytes,7,rep,name=healthcheck" json:"healthcheck,omitempty"`
	// The access grants for this vserver.
	AccessGrant []*AccessGrant `protobuf:"bytes,8,rep,name=access_grant" json:"access_grant,omitempty"`
	// Warning messages about this Vserver (such as misconfigured backends) to be
	// displayed on operator consoles.
	Warning          []string `protobuf:"bytes,9,rep,name=warning" json:"warning,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Vserver) Reset()                    { *m = Vserver{} }
func (m *Vserver) String() string            { return proto.CompactTextString(m) }
func (*Vserver) ProtoMessage()               {}
func (*Vserver) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Vserver) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Vserver) GetEntryAddress() *Host {
	if m != nil {
		return m.EntryAddress
	}
	return nil
}

func (m *Vserver) GetRp() string {
	if m != nil && m.Rp != nil {
		return *m.Rp
	}
	return ""
}

func (m *Vserver) GetUseFwm() bool {
	if m != nil && m.UseFwm != nil {
		return *m.UseFwm
	}
	return false
}

func (m *Vserver) GetVserverEntry() []*VserverEntry {
	if m != nil {
		return m.VserverEntry
	}
	return nil
}

func (m *Vserver) GetLegacyBackend() []*Host {
	if m != nil {
		return m.LegacyBackend
	}
	return nil
}

func (m *Vserver) GetBackend() []*Backend {
	if m != nil {
		return m.Backend
	}
	return nil
}

func (m *Vserver) GetHealthcheck() []*Healthcheck {
	if m != nil {
		return m.Healthcheck
	}
	return nil
}

func (m *Vserver) GetAccessGrant() []*AccessGrant {
	if m != nil {
		return m.AccessGrant
	}
	return nil
}

func (m *Vserver) GetWarning() []string {
	if m != nil {
		return m.Warning
	}
	return nil
}

type MisconfiguredVserver struct {
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	ErrorMessage     *string `protobuf:"bytes,2,opt,name=error_message" json:"error_message,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *MisconfiguredVserver) Reset()                    { *m = MisconfiguredVserver{} }
func (m *MisconfiguredVserver) String() string            { return proto.CompactTextString(m) }
func (*MisconfiguredVserver) ProtoMessage()               {}
func (*MisconfiguredVserver) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *MisconfiguredVserver) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *MisconfiguredVserver) GetErrorMessage() string {
	if m != nil && m.ErrorMessage != nil {
		return *m.ErrorMessage
	}
	return ""
}

type Attribute struct {
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Attribute) Reset()                    { *m = Attribute{} }
func (m *Attribute) String() string            { return proto.CompactTextString(m) }
func (*Attribute) ProtoMessage()               {}
func (*Attribute) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Attribute) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Attribute) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type Metadata struct {
	// The UNIX timestamp at which the Cluster configuration was last updated.
	LastUpdated *int64 `protobuf:"varint,1,req,name=last_updated" json:"last_updated,omitempty"`
	// Miscellaneous details about the Cluster configuration (info on upstream
	// source data, etc) go here.
	Attribute        []*Attribute `protobuf:"bytes,2,rep,name=attribute" json:"attribute,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *Metadata) Reset()                    { *m = Metadata{} }
func (m *Metadata) String() string            { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()               {}
func (*Metadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Metadata) GetLastUpdated() int64 {
	if m != nil && m.LastUpdated != nil {
		return *m.LastUpdated
	}
	return 0
}

func (m *Metadata) GetAttribute() []*Attribute {
	if m != nil {
		return m.Attribute
	}
	return nil
}

type Cluster struct {
	SeesawVip *Host   `protobuf:"bytes,1,req,name=seesaw_vip" json:"seesaw_vip,omitempty"`
	Node      []*Host `protobuf:"bytes,2,rep,name=node" json:"node,omitempty"`
	Vmac      *string `protobuf:"bytes,3,opt,name=vmac,def=00:00:5E:00:01:01" json:"vmac,omitempty"`
	// The local ASN for BGP peering.
	BgpLocalAsn *uint32 `protobuf:"varint,4,opt,name=bgp_local_asn,def=64512" json:"bgp_local_asn,omitempty"`
	// The remote ASN for BGP peering.  If unset, BGP will not be used.
	BgpRemoteAsn *uint32 `protobuf:"varint,5,opt,name=bgp_remote_asn" json:"bgp_remote_asn,omitempty"`
	// The BGP peers.  If empty, BGP will not be used.
	BgpPeer []*Host `protobuf:"bytes,6,rep,name=bgp_peer" json:"bgp_peer,omitempty"`
	// The service VIPs hosted by this cluster, excluding those that are
	// misconfigured (see the misconfigured_vserver attribute).
	Vserver []*Vserver `protobuf:"bytes,7,rep,name=vserver" json:"vserver,omitempty"`
	Vlan    []*Vlan    `protobuf:"bytes,8,rep,name=vlan" json:"vlan,omitempty"`
	// The list of vservers that have broken configurations.
	MisconfiguredVserver []*MisconfiguredVserver `protobuf:"bytes,9,rep,name=misconfigured_vserver" json:"misconfigured_vserver,omitempty"`
	// Metadata about this Cluster configuration.
	Metadata *Metadata `protobuf:"bytes,10,opt,name=metadata" json:"metadata,omitempty"`
	// The dedicated VIP subnet(s) for this cluster, in CIDR notation.
	DedicatedVipSubnet []string `protobuf:"bytes,11,rep,name=dedicated_vip_subnet" json:"dedicated_vip_subnet,omitempty"`
	XXX_unrecognized   []byte   `json:"-"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

const Default_Cluster_Vmac string = "00:00:5E:00:01:01"
const Default_Cluster_BgpLocalAsn uint32 = 64512

func (m *Cluster) GetSeesawVip() *Host {
	if m != nil {
		return m.SeesawVip
	}
	return nil
}

func (m *Cluster) GetNode() []*Host {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *Cluster) GetVmac() string {
	if m != nil && m.Vmac != nil {
		return *m.Vmac
	}
	return Default_Cluster_Vmac
}

func (m *Cluster) GetBgpLocalAsn() uint32 {
	if m != nil && m.BgpLocalAsn != nil {
		return *m.BgpLocalAsn
	}
	return Default_Cluster_BgpLocalAsn
}

func (m *Cluster) GetBgpRemoteAsn() uint32 {
	if m != nil && m.BgpRemoteAsn != nil {
		return *m.BgpRemoteAsn
	}
	return 0
}

func (m *Cluster) GetBgpPeer() []*Host {
	if m != nil {
		return m.BgpPeer
	}
	return nil
}

func (m *Cluster) GetVserver() []*Vserver {
	if m != nil {
		return m.Vserver
	}
	return nil
}

func (m *Cluster) GetVlan() []*Vlan {
	if m != nil {
		return m.Vlan
	}
	return nil
}

func (m *Cluster) GetMisconfiguredVserver() []*MisconfiguredVserver {
	if m != nil {
		return m.MisconfiguredVserver
	}
	return nil
}

func (m *Cluster) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Cluster) GetDedicatedVipSubnet() []string {
	if m != nil {
		return m.DedicatedVipSubnet
	}
	return nil
}

func init() {
	proto.RegisterType((*Host)(nil), "Host")
	proto.RegisterType((*Backend)(nil), "Backend")
	proto.RegisterType((*Vlan)(nil), "Vlan")
	proto.RegisterType((*Healthcheck)(nil), "Healthcheck")
	proto.RegisterType((*VserverEntry)(nil), "VserverEntry")
	proto.RegisterType((*AccessGrant)(nil), "AccessGrant")
	proto.RegisterType((*Vserver)(nil), "Vserver")
	proto.RegisterType((*MisconfiguredVserver)(nil), "MisconfiguredVserver")
	proto.RegisterType((*Attribute)(nil), "Attribute")
	proto.RegisterType((*Metadata)(nil), "Metadata")
	proto.RegisterType((*Cluster)(nil), "Cluster")
	proto.RegisterEnum("Protocol", Protocol_name, Protocol_value)
	proto.RegisterEnum("Host_Status", Host_Status_name, Host_Status_value)
	proto.RegisterEnum("Healthcheck_Type", Healthcheck_Type_name, Healthcheck_Type_value)
	proto.RegisterEnum("Healthcheck_Mode", Healthcheck_Mode_name, Healthcheck_Mode_value)
	proto.RegisterEnum("VserverEntry_Scheduler", VserverEntry_Scheduler_name, VserverEntry_Scheduler_value)
	proto.RegisterEnum("VserverEntry_Mode", VserverEntry_Mode_name, VserverEntry_Mode_value)
	proto.RegisterEnum("AccessGrant_Role", AccessGrant_Role_name, AccessGrant_Role_value)
	proto.RegisterEnum("AccessGrant_Type", AccessGrant_Type_name, AccessGrant_Type_value)
}

var fileDescriptor0 = []byte{
	// 1178 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x6c, 0x55, 0xdf, 0x6e, 0xea, 0xc6,
	0x13, 0x16, 0xc6, 0x06, 0x7b, 0xf8, 0xf3, 0x23, 0xfe, 0x25, 0xe7, 0xb8, 0x3d, 0xa9, 0x9a, 0x5a,
	0x6d, 0x15, 0x55, 0x95, 0x4f, 0x12, 0x25, 0xe7, 0x82, 0x5e, 0x54, 0x04, 0x68, 0x82, 0x44, 0x08,
	0xc2, 0x70, 0x8e, 0x7a, 0x53, 0xcb, 0xb1, 0x37, 0x60, 0xc5, 0xd8, 0x3e, 0xeb, 0x35, 0x34, 0x97,
	0xbd, 0xed, 0x1b, 0xf4, 0x05, 0xfa, 0x0e, 0x7d, 0x85, 0x3e, 0x55, 0x67, 0xd7, 0x86, 0x90, 0x28,
	0x52, 0x14, 0x76, 0x66, 0x76, 0xc7, 0xb3, 0xdf, 0xf7, 0xcd, 0x2c, 0xbc, 0x49, 0xee, 0xde, 0x7b,
	0x71, 0x74, 0x1f, 0xcc, 0x8b, 0x1f, 0x2b, 0xa1, 0x31, 0x8b, 0xcd, 0x7f, 0x4a, 0x20, 0x5f, 0xc7,
	0x29, 0xd3, 0xeb, 0x20, 0xdf, 0x7f, 0xf6, 0x23, 0xa3, 0x74, 0x24, 0x1d, 0x6b, 0xdc, 0x0a, 0x92,
	0xd5, 0xb9, 0x21, 0x1d, 0x95, 0xb6, 0xd6, 0x07, 0xa3, 0x2c, 0xac, 0x43, 0xa8, 0xa4, 0xcc, 0x65,
	0x59, 0x6a, 0xc8, 0x68, 0x37, 0xcf, 0xea, 0x16, 0x4f, 0x60, 0xd9, 0xc2, 0x67, 0x06, 0x50, 0xc9,
	0x57, 0x7a, 0x13, 0x60, 0x3c, 0xb9, 0xed, 0xcd, 0xba, 0xd3, 0xc1, 0xed, 0xa8, 0x55, 0xd2, 0x6b,
	0x50, 0x9d, 0xf6, 0xed, 0xe9, 0x60, 0x74, 0xd5, 0x92, 0x30, 0xa5, 0x7a, 0x39, 0x1b, 0x0c, 0x7b,
	0xdc, 0x2a, 0xf3, 0x90, 0x3d, 0xed, 0x8c, 0x7a, 0x97, 0xbf, 0xb6, 0x64, 0x6e, 0xfc, 0xd2, 0x19,
	0x0c, 0x67, 0x93, 0x7e, 0x4b, 0xe1, 0xfb, 0x7a, 0x03, 0xbb, 0x73, 0x39, 0xec, 0xf7, 0x5a, 0x15,
	0x6e, 0x61, 0xca, 0xf1, 0xad, 0x8d, 0x56, 0xd5, 0x3c, 0x85, 0xea, 0xa5, 0xeb, 0x3d, 0x90, 0xc8,
	0xd7, 0xff, 0x0f, 0xf2, 0x02, 0x8b, 0x10, 0xd5, 0xd7, 0xce, 0x14, 0x51, 0x91, 0xbe, 0x07, 0x95,
	0x35, 0x09, 0xe6, 0x0b, 0x26, 0xae, 0xa1, 0xb4, 0x4b, 0xa7, 0xe6, 0x8f, 0x20, 0x7f, 0x0c, 0xdd,
	0x48, 0xff, 0x1f, 0x54, 0x57, 0xf8, 0xeb, 0x04, 0xbe, 0x38, 0xa2, 0x6c, 0x13, 0x48, 0x3b, 0x09,
	0xcc, 0x3f, 0xca, 0x50, 0xbb, 0x26, 0x6e, 0xc8, 0x16, 0xde, 0x82, 0x78, 0x0f, 0xfa, 0xd7, 0x20,
	0xb3, 0xc7, 0x84, 0x88, 0x23, 0xcd, 0xb3, 0x3d, 0x6b, 0x27, 0x66, 0x4d, 0x31, 0xa0, 0xef, 0x83,
	0x1a, 0x44, 0x8c, 0xd0, 0x95, 0x1b, 0x16, 0xdf, 0x94, 0x4e, 0x4f, 0x74, 0x1d, 0xaa, 0x2c, 0x58,
	0x92, 0x38, 0x63, 0x02, 0x41, 0x2c, 0xe4, 0x82, 0x43, 0x9a, 0xc4, 0x94, 0x09, 0x08, 0xf9, 0x2d,
	0xe5, 0x14, 0xaf, 0x61, 0x28, 0x02, 0x60, 0x2c, 0x8e, 0x12, 0x8f, 0x04, 0x2b, 0x62, 0x54, 0x36,
	0xf8, 0x7b, 0xb1, 0x4f, 0x8c, 0xaa, 0xd8, 0xfc, 0x3d, 0xc8, 0x4b, 0x6e, 0xa9, 0x02, 0xfd, 0xe7,
	0x55, 0xdc, 0x60, 0xa0, 0xad, 0x8c, 0x87, 0x9d, 0xc1, 0x08, 0xf1, 0xaf, 0x2c, 0x09, 0x5b, 0xc4,
	0xbe, 0xa1, 0x89, 0x2c, 0x0d, 0x50, 0x90, 0xf3, 0xdf, 0x1f, 0x0d, 0x40, 0x53, 0xd5, 0x0d, 0x00,
	0x16, 0xa6, 0xce, 0x8a, 0xd0, 0xe0, 0xfe, 0xd1, 0xa8, 0x71, 0x5f, 0x5b, 0x66, 0x34, 0x23, 0xf9,
	0xf7, 0x19, 0x0d, 0x48, 0x6a, 0xd4, 0xf9, 0x17, 0xcd, 0xdf, 0x40, 0x16, 0xd7, 0x6b, 0x80, 0x36,
	0xe8, 0xde, 0x8c, 0x9d, 0x31, 0x67, 0xad, 0xa4, 0x57, 0xa1, 0x3c, 0xeb, 0x8d, 0x91, 0x4c, 0x5c,
	0x4c, 0xbb, 0x63, 0xe4, 0x51, 0x45, 0x31, 0x4d, 0xa7, 0x63, 0x24, 0x51, 0x03, 0x85, 0xaf, 0x6c,
	0xa4, 0x10, 0xa3, 0xbd, 0x91, 0x8d, 0xec, 0x71, 0x01, 0x74, 0xc7, 0xce, 0x74, 0x68, 0xb7, 0xaa,
	0x3a, 0x40, 0x65, 0xd2, 0xe9, 0x0d, 0x66, 0x76, 0x4b, 0x35, 0xbf, 0x04, 0x99, 0x17, 0xce, 0x0f,
	0x89, 0xd2, 0xf3, 0xdc, 0x3d, 0x7b, 0xd2, 0x92, 0xcc, 0xbf, 0xcb, 0x50, 0xff, 0x98, 0x22, 0xa4,
	0x84, 0xf6, 0x23, 0x46, 0x1f, 0xf5, 0x77, 0xa0, 0x0a, 0xe9, 0x7a, 0x71, 0x58, 0x10, 0xa1, 0x59,
	0xe3, 0xc2, 0xb1, 0x85, 0x55, 0x12, 0xa4, 0xbe, 0x07, 0x2d, 0x45, 0x5c, 0xfc, 0x2c, 0x24, 0x54,
	0x60, 0xdb, 0x3c, 0x7b, 0x6b, 0xed, 0x26, 0xb3, 0xec, 0x4d, 0xb8, 0x5d, 0xfe, 0x34, 0xec, 0xea,
	0xdf, 0x15, 0xd0, 0x56, 0xc4, 0x5e, 0xfd, 0xf9, 0x5e, 0x81, 0x2d, 0xaf, 0x0a, 0xc5, 0x52, 0x4b,
	0x08, 0x4d, 0x83, 0x94, 0x91, 0xc8, 0xdb, 0xd0, 0xb2, 0x07, 0xda, 0xe7, 0x0c, 0x31, 0xf3, 0x48,
	0xc4, 0x04, 0x37, 0x2a, 0x76, 0xca, 0x7e, 0x9e, 0xc0, 0x09, 0xe3, 0xb5, 0xb3, 0x76, 0x51, 0x19,
	0x4b, 0x97, 0x3e, 0x08, 0x3e, 0x24, 0xfd, 0x2b, 0x38, 0x28, 0xa2, 0x0b, 0x14, 0xe9, 0x4e, 0x18,
	0x44, 0x18, 0x11, 0x42, 0x5a, 0x29, 0x49, 0x17, 0x71, 0xe8, 0x0b, 0x7e, 0x14, 0xee, 0xcb, 0x9e,
	0x7c, 0x82, 0x1c, 0xfd, 0x1b, 0xa8, 0x2d, 0x9e, 0x14, 0x60, 0x34, 0x8e, 0xca, 0x28, 0xe0, 0xfa,
	0xae, 0x2a, 0xf8, 0xb1, 0x38, 0x22, 0x4e, 0xc2, 0x9b, 0x85, 0x19, 0x4d, 0x5e, 0x9b, 0x79, 0x01,
	0xda, 0xf6, 0xf2, 0x7a, 0x05, 0xa4, 0xc9, 0x24, 0x47, 0xfd, 0x13, 0x2e, 0x24, 0xee, 0x18, 0x76,
	0x91, 0x50, 0xee, 0xc0, 0x85, 0xcc, 0x1d, 0xf6, 0x75, 0x4b, 0x31, 0x8d, 0x82, 0xaa, 0x82, 0x1f,
	0x71, 0x64, 0xd4, 0x99, 0x22, 0x51, 0x7f, 0x95, 0xa0, 0xd6, 0xf1, 0x3c, 0x92, 0xa6, 0x57, 0xd4,
	0x8d, 0x18, 0x57, 0xd1, 0x9c, 0x2f, 0x08, 0x29, 0x66, 0x0a, 0x76, 0x0f, 0x8d, 0x43, 0x22, 0xb8,
	0xe1, 0xba, 0xdd, 0xd9, 0x6c, 0x4d, 0x30, 0xb0, 0x6d, 0xaf, 0xf2, 0x2b, 0x1b, 0xb8, 0xfe, 0xb8,
	0x4e, 0xc4, 0x46, 0xd4, 0x49, 0xa7, 0x77, 0xb3, 0xd1, 0xc9, 0x2d, 0xaa, 0x4c, 0x32, 0xdf, 0x15,
	0x1a, 0x45, 0x09, 0xce, 0xec, 0x3e, 0xaf, 0x0c, 0x77, 0x5d, 0x4d, 0x6e, 0x67, 0x28, 0x50, 0xf3,
	0x4f, 0x09, 0xaa, 0x05, 0x97, 0x5c, 0x22, 0x91, 0xbb, 0xdc, 0x14, 0x75, 0x08, 0x0d, 0xc2, 0xd9,
	0x75, 0x5c, 0xdf, 0x47, 0x5c, 0xd3, 0x67, 0x03, 0x00, 0x71, 0x93, 0x68, 0x22, 0xea, 0x11, 0x5d,
	0x99, 0xa5, 0xc4, 0xb9, 0x5f, 0x2f, 0x45, 0xd3, 0xaa, 0xfa, 0xb7, 0xd0, 0x58, 0x15, 0x04, 0x8a,
	0x14, 0xa8, 0x30, 0x0e, 0x7d, 0xe3, 0x99, 0x6a, 0x90, 0xe5, 0x66, 0x48, 0xe6, 0xae, 0xf7, 0xe8,
	0xdc, 0xe5, 0xb3, 0x0a, 0xc5, 0x55, 0x7e, 0xfa, 0xc2, 0x17, 0x50, 0xdd, 0xf8, 0x41, 0xf8, 0x55,
	0x6b, 0x33, 0xd3, 0x5e, 0x10, 0x5b, 0x7d, 0x85, 0x58, 0x13, 0xea, 0xae, 0x00, 0xc9, 0x11, 0x50,
	0xa3, 0xec, 0xf2, 0x3d, 0x2f, 0x78, 0x58, 0xbb, 0x34, 0x0a, 0xa2, 0x39, 0xea, 0xae, 0x7c, 0xac,
	0x99, 0x3f, 0xc1, 0xfe, 0x4d, 0x90, 0xe6, 0xaf, 0x40, 0x46, 0x89, 0xff, 0x3a, 0x30, 0x07, 0x08,
	0x0c, 0xa5, 0x31, 0x75, 0x96, 0x98, 0xc9, 0x9d, 0x93, 0xfc, 0x29, 0x30, 0x8f, 0x41, 0xeb, 0x30,
	0x9c, 0x0d, 0x77, 0x19, 0x23, 0x2f, 0x4e, 0xe0, 0x7c, 0xc1, 0xb9, 0x97, 0xe5, 0x04, 0x6b, 0xe6,
	0xcf, 0xa0, 0xde, 0x10, 0xe6, 0xfa, 0x2e, 0x73, 0x71, 0x2e, 0xd6, 0x43, 0x37, 0x65, 0x4e, 0x96,
	0xa0, 0x49, 0xf2, 0x99, 0x5b, 0x46, 0x68, 0x34, 0x77, 0x93, 0x0b, 0x0f, 0xf1, 0xd2, 0xc1, 0xda,
	0x66, 0x37, 0xff, 0x45, 0xd2, 0xba, 0x61, 0x86, 0x4d, 0x46, 0x11, 0x26, 0x48, 0x09, 0x49, 0xdd,
	0xb5, 0xb3, 0x0a, 0x92, 0xe7, 0x53, 0x1e, 0x27, 0x77, 0xc4, 0x7b, 0x56, 0xda, 0x85, 0x15, 0xa5,
	0xb4, 0x5a, 0xba, 0x5e, 0xfe, 0x62, 0xb5, 0xf7, 0x4e, 0x4e, 0xda, 0xf8, 0x77, 0xd1, 0xe7, 0xff,
	0x4f, 0x4e, 0xf1, 0x8f, 0xf3, 0x7e, 0x37, 0x4f, 0xb0, 0x2f, 0x3d, 0x37, 0x74, 0xdc, 0x34, 0x12,
	0x9c, 0x36, 0xda, 0xca, 0x87, 0xf3, 0x8b, 0xd3, 0x33, 0xfd, 0x0d, 0x34, 0x79, 0x94, 0x92, 0x65,
	0xcc, 0x88, 0x08, 0xf3, 0xe9, 0xd1, 0xd0, 0xdf, 0x82, 0xca, 0xfd, 0x09, 0xc1, 0x79, 0xf2, 0x92,
	0xc6, 0x42, 0x0b, 0x05, 0x4f, 0xea, 0x46, 0x05, 0xbc, 0x3e, 0xfe, 0xd4, 0x14, 0xdc, 0x28, 0x96,
	0x78, 0x7f, 0xce, 0xe1, 0x60, 0xb9, 0xcb, 0x81, 0xb3, 0x39, 0xad, 0x89, 0x5d, 0x07, 0xd6, 0xab,
	0x0c, 0xe1, 0xe8, 0x5b, 0x16, 0x90, 0x8a, 0x21, 0x51, 0xc3, 0xd1, 0xb7, 0xc5, 0x18, 0x87, 0x8d,
	0x4f, 0xfc, 0xc0, 0xe3, 0x00, 0x73, 0x94, 0x9c, 0x34, 0xbb, 0x8b, 0xb0, 0xdd, 0x6b, 0x9c, 0xf4,
	0x1f, 0x0e, 0xf1, 0xe5, 0xdc, 0x0c, 0xc9, 0x62, 0x5c, 0x3f, 0x0d, 0xf0, 0xff, 0x02, 0x00, 0x00,
	0xff, 0xff, 0x5d, 0xb7, 0x57, 0xd0, 0x1e, 0x08, 0x00, 0x00,
}
